---
title: ë°±ì¤€ 1167 íŠ¸ë¦¬ì˜ ì§€ë¦„ (Java)
excerpt: íŠ¸ë¦¬ì˜ ì„±ì§ˆì„ ì´ìš©í•´ ë°±ì¤€ 1167 íŠ¸ë¦¬ì˜ ì§€ë¦„ ë¬¸ì œë¥¼ í’€ì–´ë³´ì.
categories: [algorithm]
tags: [ë°±ì¤€1167, íŠ¸ë¦¬ì˜ì§€ë¦„, java, ì•Œê³ ë¦¬ì¦˜, íŠ¸ë¦¬]
image:
  path: /assets/img/algorithm/covers/ì•Œê³ ë¦¬ì¦˜_ì»¤ë²„.png
---

## ğŸ” ë¬¸ì œ
[1167. íŠ¸ë¦¬ì˜ ì§€ë¦„](https://www.acmicpc.net/problem/1167)

## ğŸ” í’€ì´
### âœï¸ íŠ¸ë¦¬ì˜ ì •ì˜ ë° íŠ¹ì„±
- ì‚¬ì´í´ì´ ì—†ëŠ” ë¬´ë°©í–¥ ê·¸ë˜í”„
- ëª¨ë“  ì •ì ì´ ì„œë¡œ ì—°ê²°ë˜ì–´ ìˆë‹¤.

### âœï¸ ì ‘ê·¼ ë°©ë²•
íŠ¸ë¦¬ë„ ê·¸ë˜í”„ì˜ ì¼ì¢…ì´ë¯€ë¡œ ê·¸ë˜í”„ë¥¼ ì¼ì§ì„ ìœ¼ë¡œ í´ì„œ ë‚˜ì—´í•´ë³¼ ìˆ˜ ìˆë‹¤.

![1167.png](..%2F..%2Fassets%2Fimg%2Falgorithm%2F1167.png)

ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ ì¤‘ ê°€ì¥ ê¸´ ê²ƒì„ ì°¾ê¸° ìœ„í•´ì„œëŠ” ë§ˆì§€ë§‰ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ íƒìƒ‰í•´ë‚˜ê°€ì•¼ í•œë‹¤. (4 ë˜ëŠ” 3)
ë”°ë¼ì„œ ì½”ë“œì˜ ë¡œì§ì€ ë‹¤ìŒ ë‘ ë‹¨ê³„ë¡œ ë‚˜ëˆ ì§ˆ ê²ƒì´ë‹¤.

1. ë§ˆì§€ë§‰ ì •ì ì„ êµ¬í•œë‹¤.
2. ë§ˆì§€ë§‰ ì •ì ì„ ê¸°ì¤€ìœ¼ë¡œ ê°€ì¥ ê¸´ ê²½ë¡œë¥¼ ì°¾ëŠ”ë‹¤.

### âœï¸ ì£¼ì˜ !
- ë°©í–¥ ê·¸ë˜í”„ë¥¼ í‘œí˜„í•˜ê¸° ìœ„í•´ 2ì°¨ì› ë°°ì—´ì„ ì´ìš©í•˜ë©´ ë©”ëª¨ë¦¬ ì´ˆê³¼ê°€ ë°œìƒí•œë‹¤.
  - 100,000 * 100,000 * 4byte = 40GB

## ğŸ” ì½”ë“œ
~~~javascript
public class Q1167 {

    
    static List<List<Node>> list = new ArrayList<>();
    static boolean[] visited;

    static class Node {
        int index;
        int distance;
        Node(int index, int distance) {
            this.index = index;
            this.distance = distance;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int V = sc.nextInt();
        visited = new boolean[V + 1];
        for (int i = 0; i <= V; i++) {
            list.add(new ArrayList<>());
        }

        for (int i = 1; i <= V; i++) {
            int current = sc.nextInt();
            while (true) {
                int next = sc.nextInt();
                if (next == -1) {
                    break;
                }
                int distance = sc.nextInt();
                list.get(current).add(new Node(next, distance));
                list.get(next).add(new Node(current, distance));
            }
        }

        // 1.ë§ˆì§€ë§‰ ë…¸ë“œ ì°¾ê¸°
        visited[1] = true;
        DFS(1, 0);

        // 2. íŠ¸ë¦¬ì˜ ì§€ë¦„ ì°¾ê¸° 
        max = 0;
        visited = new boolean[V + 1];
        visited[maxNode] = true;
        DFS(maxNode, 0);
        System.out.println(max);
    }

    static int max = 0;
    static int maxNode = -1;

    private static void DFS(int N, int distance) {
        if (distance > max) {
            max = distance;
            maxNode = N;
        }
        for (Node node : list.get(N)) {
            if (!visited[node.index]) {
                visited[node.index] = true;
                DFS(node.index, distance + node.distance);
            }
        }
    }
}
~~~

